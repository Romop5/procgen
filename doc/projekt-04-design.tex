%03 Navrh jazyka
%============
\chapter{Návrh jazyka}

Jazyk, ktorý bol navrhnutý v tejto práci vychádza vo svojom základe z \textbf{L-systémov}.
Základom jazyka sú symboly a pravidlá, ktorými sa odvodzujú nové symboly.


\section{Definícia jazyka}
Fungovanie programu popísaného našim jazykom je založené na prepisovaní typovaných symbolov.

Po spustení programu sa vytvorí uživateľom definovaný počiatočný reťazec symbolov s počiatočnými hodnotami.
Následne prebiehajú takzvané prepisovacie cyklusy. V každej iterácii sa postupne pre každý symbol aktuálneho reťazca
vyhodnotia všetky definované pravidlá pre jeho typ a z množiny prípustných pravidieľ sa náhodne vyberie. Prípustnosť pravidla je založená na vyhodnotení logiky pravidla, ktorej vstupom sú jednotlivé zložky symbolu.

Vybrané pravidlo je aplikované a jeho aplikáciou môžu vniknúť nové symboly, ktoré sa pridajú na koniec reťazca pre ďalšiu iteráciu.
V prípade, že žiadne z pravidieľ nie je aplikovateľné, je tento symbol taktiež pridaný k ďalšej iterácii.

Výpočet je ukončený v momente keď počas iterácie nebolo použité ani jedno z uživateľových pravidiel.

\subsection{Symboly}
Symboly sú typované. Každý uživateľom definovaný symbol predstavuje unikátny typ, ktorý predstavuje štruktúru, zloženú z atomických (preddefinovaných typov) alebo
z iných kompozitných typov. Jednotlivé zložky majú vrámci štruktúry unikátny názov, ktorý predstavuje ich identifikáciu.

\subsection{Pravidlá a funkcie}
Uživateľ taktiež špecifikuje pravidlá. Každé pravidlo je zložené z dvoch časti: \textbf{predikátovej funkcie} a \textbf{procedúry}.

Predikátová funkcia zobrazuje parametre symbolu na boolovskú hodnotu, ktorá určuje, či je pravidlo aplikovateľné na
aktuálny symbol. 

Precedúra pravidla predstavuje akciu, resp. súbor akcií, ktoré sa majú vykonať pri aplikácii pravidla na symbol. 

Pri špecifikovaní pravidla uživateľ definuje obe zložky pravidla. Telo každej zo zložiek je tvorené sekvenciou príkazov. Príkaz je buď jednoduchý (napr. priradenie) alebo zložený (cyklus, podmienka). Príkazy rovnako pracujú s výrazmi, ktoré predstavujú vyčísliteľnú hodnotu s typom.

Pre zvýšenie komfortu je rovnako možné definovať vlastné pomocné funkcie, ktoré je následne možné použiť v iných funkciach a výrazoch. 
Jazyk ale striktne nepovoluje rekurziu pri volaní funkcií.

\subsection{Derivačný strom}
Pre zabezpečenie kontextovosti jazyka je zavedený takzvaný prístup k derivačnému stromu. Pomocou tohoto mechanizmu je možné pristupovať k symbolom, ktoré boli derivované v tej istej iterácii systému (pravý a ľavý kontex) ako aj ku symbolu, ktorého deriváciou vznikol. 

\section{Vlastnosti jazyka}
Z predchádzajúcej definície jazyka môžeme konštantovať niekoľko vlastností jazyka. Jazyk má nasledujúce vlastnosti:
\begin{itemize}
\item parametrickosť - zabezpečená definovaním symbolu ako štruktúry, zavedení predikátovej funkcie
\item stochastickosť - umožnená definíciou viacerých pravidiel pre identický symbol
\item kontextovosť - vďaka dostupnosti mechanizmu pre prístup ku derivančému stromu
\end{itemize}

\section{Objektový návrh}
Pred samotnou implementáciou jazyka je nutné premyslieť ako sa budú jednotlivé aspekty jazyka mapovať na štruktúry v kóde, ako budú jednotlivé štruktúry uložené v pamäti a ako budú vyzerať ich vzájomné väzby. Vzhľadom na rozhodnutie implementovať jazyk v jazyku C++ je vhodné zvoliť objektovo orientovanú analýzu a návrh. 
\subsection{Symboly}
Ako už bolo zmienené, symboly sú kompozitné typy. Je teda nutné vytvoriť rozhranie, ktoré umožňí definovať atomické aj zložené typy a pre tento účel je vhodné využiť návrhový vzor \textit{Composite} (TODO).  Rovnako uchovanie samotného typu vyžaduje uložiť metadáta typu (jednoznačný identifikátor, názov, prípadne podtypy) a samotné inštancie typov. 

Hodnoty typov sú reprezentované abstraktnou triedou \texttt{Resource}, ktorá uchováva identifikáciu typu a typ typu. Pomocou dedičnosti sa následne rozlišuje medzi atomickým (\texttt{AtomicResource} a kompozitným typom \texttt{CompositeResource}.

\begin{figure}[ht]
\caption{Objektová hierarchia tried pre reprezentáciu typu.}
\centering
\begin{tikzpicture}[show background grid]
	\begin{abstractclass}[text  width=6cm]{Resource}{0,0}
		\attribute{- typeId}
		\operation{getTypeId()}
	\end{abstractclass}
	\begin{class}[text  width=4cm]{AtomicResource}{-4,3}
		\inherit{Resource}
		\attribute{- data}
		\operation{getTypeId()}
		\operation{getData(): void*}
	\end{class}
	\begin{class}[text  width=4cm]{CompositeResource}{4,3}
		\inherit{Resource}
		\operation{getTypeId()}
		\operation{getComponent(id): AbstractResource}
	\end{class}

	\aggregation{CompositeResource}{components}{n}{AtomicResource}
\end{tikzpicture}
\end{figure}



Z hľadiska uloženia metadát sa javí neefektívne ukladať popis typu v každej inštancii typu. Preto je nutné zaviesť akýsi register, ktorý by uchoval popis typu na jednom mieste. Z toho dôvodu je pridaná trieda \texttt{TypeRegister}, ktorej účelom je spravovať definované typy ako aj ponúkať mechanizmus k tvorbe inštancii takýchto typov. 
Pre každý typ obsahuje tento register inštanciu triedy \texttt{TypeDecriptor}, asociovanú s menom typu ako aj konštruktor hodnoty tohoto typu. 


Vzhľadom na fakt, že typ môžeme byť buď atomický alebo kompozitný, je nutné aj popis typu členiť do hierarchie tried. Trieda \texttt{TypeDecriptor} predstavuje potom abstraktné rozhranie k triedam \texttt{AbstractType} a \texttt{CompositeType}. Posledná z nich obsahuje odkazy na iné \texttt{AbstractType} a k nim asociované názvy zložiek.


\subsection{Príkazy a výrazy}

Pre realizáciu pravidiel je nutné navrhnúť spôsob, akým bude implementovaná logika, ktorá je v tomto jazyku založená na príkazoch. Obecne pre ľubovoľný príkaz platí, že je vykonateľný a výsledkom jeho vykonanie je zmena stavu. 

Keďže existuje niekoľko typov príkazov, môžeme modelovať príkaz ako abstraktnú triedu a konkrétne typy príkazov ako triedy, ktoré rozširujú tento príkaz. 

Jednoduché výrazy sú modelovená triedou \texttt{Function}. Táto trieda prestavuje modul, ktorý má vstupy a výstup. Vstup je realizovaný pomocou odkazov na iné inštancie triedy
\texttt{Function}, kdežto výstup sa viaže na inštanciu triedy \texttt{Resource}. Tento model umožňuje vytvárať komplexné výrazy, ktoré sú potom realizované vyhodnotením podvýrazov a operáciou nad nimi. Taktiež musí existovať špeciálna tzv. \textit{nulárna funkcia}, ktorá umožňuje sprístupniť typovú hodnotu (inštanciu \texttt{Resource}) ako vstup do modulu.

Výrazy sú teda realizovateľné ako stromy, ktorých listami sú nulárne funkcie, uzlami operácie a výsledkom je hodnota.

Príkaz môže byť taktiež zložený a vtedy sa jeho vykonaním postupne vykonajú príkazy, z ktorých sa skladá. Takýto príkaz sa nazýva sekvenciou príkazov a je modelovaný triedou \texttt{Body}. 

Aby bolo možné implementovať príkazy, ktorých vykonanie je podmienené stavom premenných, je nutno pridať podmienený príkaz. Ten reprezentuje trieda \texttt{If} a umožňuje vykonať jeden z dvoch príkazov v závislosti na platnosti podmienky, teda logického výrazu.

Nakoniec, pre úplný výpočetný model je nutné pridať konštrukciu, ktorá umožní opakovaný výpočet na základe splnenia výrazy. To je zabezpečené triedou \texttt{While}, ktorá zastupuje rovnomenný cyklus.

Konštrukcie, ktoré sme si práve uviedli nám umožňujú realizovať ľubovoľnú sekvenciu príkazov. Pre uživateľa by bolo vhodné keby si mohol vytvoriť vlastnú funkciu, ktorá by mala vstupy a výstupy a vnútri by bola realizovaná pomocou obyčajných príkazov. Z tohoto dôvodu je nutné zaviesť triedu \texttt{FunctionRegister}, ktorá umožní definovať uživateľské funkcie a následne vytvoriť ich inštancie, ktoré môžu byť použité v prípade bežných výrazov.

\subsection{Pravidlá a mechanizmus derivácie}


